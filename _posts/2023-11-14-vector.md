---
layout: single
title: 탐색알고리즘 알고리즘
---

# 방향벡터 알고리즘
2차원배열 특정 원소로부터(보통 2차원)에서 가로,세로(4방향) 혹은 대각선 포함(8방향)탐색을 할때 사용하는 알고리즘임.  
  

구현 방법은 기준으로 선정한 원소의 방향을 direction 배열의 원소를 더해 nx,ny를 만들고, 문제의 조건에 맞게 탐색을 하면된다.  


## swea 4615번 재미있는 오셀로
오셀로 게임 알제? 어렸을때 windowXP에 있는 기본 겜ㅇㅇ  
게임순서를 입력받으면 흰색과 검은색 알의 개수를 각각 세는 프로그램을 만들어라.  

```python
t = int(input())

direction = [(0, 1), (1, 0), (-1, 0), (0, -1), (1, 1), (-1, 1), (1, -1), (-1, -1)]
for tc in range(1, t + 1) :
    n, m = map(int, input().split())
    board = [[0] * n for _ in range(n)]

    mid = n // 2
    board[mid][mid] = 2 # 백
    board[mid-1][mid-1] = 2 # 백
    board[mid-1][mid] = 1 #흑
    board[mid][mid-1] = 1 #흑

    for i in range(m) :
        x, y, t = map(int, input().split())
        x, y = x-1, y-1

        data = []
        for i in range(8) :
            dx, dy = direction[i]
            nx = x + dx
            ny = y + dy
            while True :
                if not (0 <= nx < n and 0 <= ny < n) :
                    data = []
                    break
                if board[nx][ny] == 0 : # 빈 칸일 경우
                    data = []
                    break
                if board[nx][ny] == t : # 같은 돌일 경우
                    break
                else :
                    data.append((nx, ny))
                nx, ny = nx + dx, ny + dy

            for tx, ty in data :
                # 같은 돌로 갱신
                if t == 1 :
                    board[tx][ty] = 1
                elif t == 2 :
                    board[tx][ty] = 2
        board[x][y] = t

    W_cnt, B_cnt = 0, 0
    for i in range(n) :
        W_cnt += board[i].count(2)
        B_cnt += board[i].count(1)

    print('#%d %d %d' % (tc, B_cnt, W_cnt))
```
8방향백터문제. nx,ny가 board의 인덱스 범위 내에서 노는지 확인하고, 빈칸이 나오거나, 같은 돌이 나올때까지 data(temp역할)배열에 넣어 검사한다.  



## swea 11315번 오목 판정 
게임판의 상태가 입력됬을때, 오목이 완성됬는지, 아닌지 검사하는 프로그램.
```python
T = int(input())
direction = [(0,1),(1,0),(0,-1),(-1,0),(1,1),(-1,1),(1,-1),(-1,-1)]
for t in range(1,T+1):
    N = int(input())
    arr = [list(map(str,input()))for _ in range(N)]

    OHMOK = "NO"

    for i in range(N):
        for j in range(N):
            if arr[i][j] == 'o':
                x,y = i,j
                for d in range(8):
                    temp = [arr[x][y]]
                    dx,dy = direction[d]

                    nx = x + dx
                    ny = y + dy
                    while True:
                        if not (0 <= nx < N and 0 <= ny < N):
                            temp = []
                            break
                        else:
                            temp.append(arr[nx][ny])
                            nx,ny = nx+dx,ny+dy
                            if len(temp) == 5:
                                if temp ==['o','o','o','o','o']:
                                    OHMOK ="YES"
                                break

    print(f"#{t}",OHMOK)
```
오셀로 게임과 마찬가지로 8방향으로 검사한다  
'o'가 연속 5개  나오면 break를 하고 "YES"출력한다  
